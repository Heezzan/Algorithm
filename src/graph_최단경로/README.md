## 최단경로 문제
A->B로 가는 최단경로는 최대 N-1개의 간선으로 이루어져 있다.

### 다익스트라
모든 간선에 대해 `dist[to] > dist[from]+cost` 일 때 `dist[to] = dist[from]+cost` 작업 수행  
음수 가중치가 있을 때 사용할 수 없으며, 모든 간선에 대해 식을 한번만 검사한다.  
시간복잡도 : O(V^2) / Heap 이용하면 O(ElogE)
 
### 벨만포드
모든 간선에 대해 `dist[to] > dist[from]+cost` 일 때 `dist[to] = dist[from]+cost` 하는 과정을 V-1번 반복 (간선이 V-1개여서)  
음수 가중치가 존재할 때 사용할 수 있으며, 음수 사이클을 검사할 수 있음 (V-1번 반복한 결과와 V번 반복한 결과가 다를 경우)  
시간복잡도 : O(V*E) = (V-1) * O(E)
 
### 플로이드
모든 쌍의 최단 경로를 구하는 알고리즘
``` 
for (int k = 1; k <= n; k++) {
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= n; j++) {
            if (d[i][j] > d[i][k] + d[k][j]) 
                d[i][j] = d[i][k] + d[k][j];
        }
    }
}
```
O(V^3)이기 때문에 정점의 개수가 500보다 작을 때 주로 사용